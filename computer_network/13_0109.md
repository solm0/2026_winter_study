# Network security란?
네트워크 보안 3요소
- 기밀성(Confidentiality): sender/receiver만이 메시지를 이해할 수 있어야
- 무결성(Integrity): 메시지가 바뀌면 안됨
- 가용성(Availability): 필요한 시점에 서비스를 이용할 수 있어야 한다.

그외
- authentication: sender/receiver가 서로의 정체를 확인할 수 있어야 한다.

Trudy가 메시지를 중간에 intercept, delete, add할 수 있다.






## Cryptography
- m: plaintext message
- Ka(): A의 encryption key
  - Ka(m): ciphertext
- Kb(): B의 decryption key
  - m = Kb(Ka(m))

## encryption이 부서지는 방법들
- cipher-text only attack
  - Trudy가 ciphertext를 분석할수있음. 예: brute force, statistical analysis
- known-plaintext attack
  - Trudy에게 ciphertext에 대응하는 plaintext가 있음
- chosen-plaintext attack
  - Trudy가 특정 plaintext의 ciphertext를 얻을 수 있음

## Symmetric key cryptography
밥과 앨리스가 Ks라는 하나의 key 공유

m -> Ks(m) -> m=Ks(Ks(m))

단점: 동기화(key 전달) 어려움

예1: substitution cipher
- 한 문자를 다른 문자에 대치하는 것(예: monoalphabetic cipher)
- key: 26글자->26글자 맵
- 약점: brute force로 깨질수도있음, 코드북이 유출되면 소용이 없음.

예2: cycling pattern
- substitution cipher를 n개 준비. M1 M2 M3 ... Mn
- 그리고 돌아가면서 씀. 예: n=4면 M1 M3 M4 M3 M2
- key: n substitution cipher와 cyclic pattern






# 현대 암호의 분류
- 대칭키 암호: 스트림 암호(RC4,LFSR), 블록 암호(DES,SEED)
- 해쉬 함수(SHA1,HAS160)
- 공개키 암호(=비대칭키 암호): 이산 대수(DH,DSA), 소인수 분해(RSA)

블록, 소인수분해 많이씀

## 대칭키 - DES (Data Encryption Standard)
- 대칭키 암호, 블록

- 56bit 대칭키, 64bit plaintext 인풋
- cipher block chaining?이뭔데
- 하루 안에 brute force로 털림 가능 -> 3DES: 3개의 key로 3번 encrypt

## 대칭키 - AES (Advanced Encryption Standard)
- DES 대체함
- 128/192/256bit 대칭키, 128bit 인풋?
- DES에 1초걸리는 brute force가 AES에서는 149조년(..!)

## 공개키
대칭키에서는 sender/receiver가 같은 secret key를 공유해야 한다.
근데 공개키방식에서는 sender/receiver가 secret key를 공유하지 않는다.
- public encryption key: 모두에게
- private decryption key: receiver만.

- Kb+(): B의 public key
- Kb-(): B의 private key

m -> Kb+(m) -> m=Kb-(Kb+(m))

### RSA (Rivest,Shamir,Adelson) algorithm
공개키 알고리즘의 요건
- m=Kb-(Kb+(m))을 만족하는 Kb+()와 Kb-()
- Kb+() 퍼블릭키로 Kb-() 프라이빗키를 알아낼 수 없어야함.
-> RSA

특징
- Kb+(Kb-(m)) = m = Kb-(Kb+(m))임.
- exponentiation 즉 거듭하면 연산 너무 많음. DES보다 암호화는 강한데 속도가 느림

그래서 실제로는 처음 보안 connection을 만들땐 공개키 방식 쓰고 그다음에는 대칭키써서 데이터 암호화함.
예시: 대칭키 Ks()를 공유하기 위해서 RSA를 사용한다. Ks를 받고 나면 그것만사용함.


## 해쉬 함수
긴 메시지는 공개키로 하기 복잡함.
fixed-length, 연산하기 편한 'digital 지문인식' 필요
-> 해쉬 함수 H()

특징
- 다대일
- 고정된 사이즈의 메시지 digest(지문인식) <-뭔소리?
- 연산적으로 x = H(m)을 찾을 수 없음. 뭔소리?

다양한 알고리즘이 있음
MD5가 많이 쓰임. 128bit 메시지를 4단계로 digest함.
SHA-I도 쓰임. 160bit 메시지를 digest함

digest한다는게뭐임?






# Authentication
본인임을 증명하기.

protocol ap1.0: '나 앨리스야'
-> Trudy도 '나 앨리스야'할 수 있음

protocol ap2.0: '나앨리스'+ ip주소
-> Trudy가 앨리스 ip주소쓸수있음(spoofing)

protocol ap3.0: '나앨리스'+ ip주소 + 비밀번호
-> Trudy가 앨리스 패킷 기록해놨다가 보낼 수 있음(playback attack)

protocol ap3.1: '나앨리스'+ ip주소 + 암호화된 비밀번호
-> playback attack가능;;

protocol ap4.0: '나앨리스'+ ip주소 + 암호화된 비밀번호
-> 밥이 nonce R 보냄
- nonce: once-in-a-lifetime 한번만사용되는 숫자 R
-> 그럼 앨리스는 R을 공유된 secret key로 암호화해서 돌려줌
-> 밥은 앨리스를 믿음

protocol ap5.0: auth에 공개키 기술 적용.
밥이 nonce R 보냄
-> R을 앨리스가 프라이빗키로 암호화해줌
-> 밥이 퍼블릭키 요청함
-> 앨리스가 퍼블릭키 보내줌
-> 밥은 암호화된 R을 퍼블릭키로 복호화해서 R 확인

## man in the midle
ap5.0의 구멍
Trudy가 중간에서서 앨리스한테는 밥인척 밥한테는 앨리스인척함
-> 밥이 보내는 모든걸 앨리스가 받고 앨리스가 보내는 모든걸 밥이 받아서 알기 어려움..

## Digital signature
문서에 디지털서명하기
- verifiable(증명가능한), nonforgeable(대체불가능)?

밥이 m을 자기 프라이빗키 Kb-()로 encrypt함으로써 sign함
- Kb-(m): signed message

앨리스가 밥의 인증서를 얻어서
CA (Certification Authority)의 퍼블릭키를 밥의 인증서에 적용해 밥의 퍼블릭키를 얻음



## Secure Email
하이브리드형태

앨리스가
- 랜덤 대칭키 Ks 생성 -> Ks(m)
- Ks를 밥의 퍼블릭키로 encrypt -> Kb+(Ks)
- 둘다 밥한테 보냄

밥은
- 자기 프라이빗키로 decrypt -> Kb-(Kb+(Ks))=Ks
- Ks로 m decrypt -> Ks(Ks(m))=m

AES?는뭐더라



# SSL (Secure Sockets Layer)
많이사용되는 보안프로토콜
https
소켓에서사용가능?

SSL을 사용하면 헤더가 `application SSL TCP IP` 이렇게 됨
SSL은 application에게 API를 제공








# IPsec
> 전체 흐름을 재정리하자
> 이거 중심으로.

기밀성, 무결성, 인증(replay attack 예방)을 위해
ip단 보안 프로토콜

AH (Authentication Header) 프로토콜: 헤더에서. 기밀X 인증만. 이제 거의안쓰임
ESP (Encapsulation Security Protocol): 기밀성,무결성,인증

(인증방식이 IKE
세션관리 위해 SA
그걸 사용한게 VPN)?

# VPN (virtual private network)
회사는 보통 보안을 위해 네트워크를 제한하고싶어함.
독립된 라우터,링크,DNS인프라를 둔다던지.

하지만 직원이 출장가서 회사네트워크 접속해야한다거나 할때 트래픽이 public internet을 뚫고가야함
그럴려면
- public internet 들어가기 전에 데이터가 encrypt되어야
- 다른 트래픽과 논리적으로 분리되어야.?

그러기 위해 IPsec을 이용함.

public internet과 연결된 것들
- 헤드쿼터
  - host들 <-> 라우터(IPv4,IPsec): ip헤더+payload
  - 라우터 <-> 인터넷: ip헤더+IPsec헤더+payload
- 브랜치 오피스
  - host들 <-> 라우터: ip헤더+payload
  - 라우터 <-> 인터넷: ip헤더+IPsec헤더+payload
- 호텔에있는 직원
  - 노트북 <-> 인터넷: ip헤더+IPsec헤더+payload


# Security association (SA)
데이터 보내기 전에 SA가 sender와 receiver사이 만들어진다. 단방향.
state info 있음 TCP처럼
그래서 ip는 connectionless여도 IPsec은 connection-oriented임

# IKE (internet key exchange)
협상과정이 필요함. 어떤인증체계를 쓸지.
전처리과정. handshaking같이.

- PSK (Pre shared key)
  - 둘다 secret으로 시작. 대칭키처럼?
  - IKE (Internet Key Exchange) 실행해서 서로를 인증하고 IPsec 단방향 SA(encryption, authenticaion key 공유?) 생성
- PKI (public key infrastructue)
  - 둘다 프라이빗/퍼블릭 키 쌍과 인증서로 시작
  - IKE 실행해 서로 인증하고 IPsec SA얻음
  - SSL의 handshake와 유사

뭐지




# 무선에서는? WEP
유/무선의 환경이 달라서 기술이 다르다

- 대칭키 암호 - 기밀성, 무결성, host인증
- 스스로 동기화하기: 패킷들은 독립적으로 암호화됨. 주어진 암호화된 패킷과 키는 복호화될 수 있다. 이전 패킷이 lost됐어도 이어서 복호화 가능
- 효율적: 하드웨어/소프트웨어에 구현가능

## WEP authentication
1. host -> AP: authentication req보냄
2. AP -> host: 128 bytes nonce보냄
3. host -> AP: 대칭키로 nonce암호화해 보냄
4. AP -> host: 일치하면 success

모든 AP가 하지는 않음
authentication이 필요하면 AP가 하라고함
association 전에 이루어짐
이게와이파이비번인가??

# EAP (Extensible authentication protocol)
WEP의 확장. 유무선 통합 보안체계

mobile -> AP: EAP over LAN
AP -> 인증서버: RADIUS over UDP

어 버스와이파이에서 radius 봤는데




# Firewall
유무선 상관없음

기관 내부망과 인터넷의 경계에서 해커액세스만 걸러주기
gateway에서 막아야함.

패킷 필터링
- TCP/IP 헤더만 취급하기
- session 간 correlation check는 안함

## Intrusion detection system (IDS)
방화벽 잘 구축했어도 이미 침투한 악성코드가 있는지 확인하기 위해

- deep packet inspection: 패킷의 콘텐츠까지 봄
  (알고있는 바이러스랑 문자열 데이터베이스에서 체크)
- examine correlation: 여러 패킷들 사이 관계 평가
  - port scanning
  - network mapping
  - Dos attack

IDS 여러개 여기저기 두기
IPS: protection. 미리 예방.