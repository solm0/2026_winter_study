# Reliable Data Transfer
네트워크가 안정적이어서 오류가 없으면 좋겠지만? (=reliable channel)

그렇지 않기 때문에(=unreliable channel)
- 물리적으로 안좋을수있고 트래픽이 다르고 차량이 움직이고 등등 언제든지 loss는 생길수있다(physical이든 logical이든)

그래서 TCP라는 안전망이 나옴







# Single Flow
ARQ: 네트워크에서 TCP에서 쓰는 오류 제어를 위해 쓰는 스킴. 문제가 생기면 재전송을 해주는. Automatic repeat request. 자동으로 반복적으로 리퀘스트를 하게함.

재전송을 하려면 받았는지 안받았는지 알아야. syn을 보내면 ack를 받자

## stop-and-wait
request를 stop하고 wait하기.왜?

ack: 하나 보내면 잘갔다고 확인해주는것. request가 잇으면 항상 response가 있게하기.
sequence number: 근데 여러개보내니까 구분하기 위해 identifier 번호가 있어야한다.



가다가 packet이 loss될 수 있고 받았는데 ack가 loss될수잇고
그럼 타임아웃을 얼마나 해야? 뭘 기준으로 기다려야? RTT.
- 타임아웃이너무빨라서 안가도되는 패킷을 또보내면 굉장히 비효율적. 그래서 각자 자기 환경에서의 ttl을 잘 설정해야 한다. 정확하게 예측하기는 어렵다. 확률게임.

stop-and-wait의 문제: 한개보내고 한개나오고 -> HTTP1.0처럼 효율이 떨어짐. multiple로 보낼수없을까?






# Pipelined protocol
여러개.
응답이 없더라도 여러개를 request 동시에보냄. request마다 타임아웃을 설정.

두 방법이 있음.
문제가 생겼을때 어떻게 처리하느냐의 차이

## Go-back-N
받으면 window sliding. window size는 내가 보낼수있는 사이즈. adaptive함. 환경이 좋으면 많이 보냄. 안좋으면 window size를 줄임. max-low threshold 사이에서 늘렫다 줄였다 -> congestion control

안 온 번호로 가서 걔부터 다시 보냄.
> 그 다음꺼 이미 보냈더라도 무시(in-order). 버림
순서 틀린애들은 다 못갔다고 침.
 그럼 한번에 얼마나 많이 보내야 할까? 네트워크 환경에 따라 바꿔야됨.

10개를 보낼수있어서 보냈는데 응답이 오면 옆으로 옮겨감 -> sliding window

cumulative ack. 마지막으로 잘보낸것을 ack하는.

> window size 안에서 문제 n으로 돌아간 다음에 이미 보냈던 sequence까지 다시 보내준다.

send,receive얘기 둘다 써야함.



## Selective Repeat
Go-back-N은 순서가 중요함. 7번못받았는데 8번오면 8번 버려야됨. -> 비효율적.

잘보낸건 buffer에 저장한다. 7이 나중에 오면 assemble해서 올려보내기. 선택해서 재전송. 문제있는 sequencenumber만 보냄.
이거 하려면 receiver에도 버퍼가있어양하고 assemble해야해서 좀더 복잡한.

응답이 순서대로 와야한다는 규칙이 없음. window size안에서 어디서든 오면 그냥 받아줌.

### Selective Repeat의 딜레마
id관리를 잘해야한다. 데이터타입.흔한실수
sequence number의 max. 범위를 어디까지 둘 것인가?
wraparound? 255까지하면 256은 0이됨.
max가 2일경우 3이못가고 ack는 1 왔고 그다음 0을 보내ㅐ야 하는데 처음보낸 0이랑 다른 애지만 번호가 똑같은데 receiver는 앞에 0을 처리했기 때문에 문제없음
근데 만약 0의 ack가 깨졌다 -> sender는 다시 앞에 0을 보낸다 -> receiver는 이미 앞에 0을 처리했으니까 그게 다음 0이라고 생각한다.
그래서 범위를 잘 설정해야 함.
너무 크게해도 비효율적임.

> ARQ의 세가지: Stop-and-Wait, Go-back-N, Selective Repeat 차이 설명하기.
> sliding windo설명,번호문제생겼을때 행동 예시들어 비교하기.
> 그냥 그림 통째로 외우자...





# TCP overview
ARQ의 공통점은 receiver측에서 in-order방식으로 해줘야함. 그 과정에서 문제가 생겼을때의 처리만 out-of-order가 있는거지 TCP는 다 in-order임.

> 특징 다 외우기
point-to-point: coonnection이이씅ㅁ. sender하나 receiver하나
pipelined: window
full-duplex: 양방향.
connection-oriented: handshake
flow controlled: receiver가 받을수있는만큼만 보내주자. 리시버만 바라보는게 flow control. congestion은 네트워크 전체를 바라보는거고.

## TCP header
> 헤더 특히 setup, closing bit외우기
- not used: TCP구현하는사람들에 따라서 부가적인 정보를 넣을수있는공간.
- sequence number와 ack number를 다르게할수있다? seq 42면 receiver는 ack를 줄때 +1을 돌려줄수있음. seq는 보내는입장, ack는 받는입장. 받는입장에서 seq에 +1을 해서 ack에 넣어줄수있음.

> 재전송 시나리오
또 어떨때는 seq에 더하는 것을 byte로 할수있음. seq 92 byte 8이면 ack 100을 주는 것임.
어떤 케이스에서는 ack가 문제가있어서 느리게갔음 -> 전에거가 타임아웃났음premature -> 재전송했음 -> receiver는 그걸받고 마지막으로 보낸 ack를 다시보냄. 이 ack가 자꾸 생기면(3번) 문제가 있다고 판단함.

100 ack가 제대로안갔는데 120이 갔으면 sender 입장에서는 앞에거가 잘 받았는지 판단하기 어렵다(실제로는 받았는데) -> 120을 주는 순간 앞에있는게 유실이 됐어도 잘 받았다고 확인이 된다면 재전송 안함. 재전송 숫자를 줄일 수 있다는 케이스. 근데 잘 받았는지 어떻게 아는데?




# TCP RTT(round trip time)
타임아웃이 중요해서 RTT기준으로 타임아웃을 정한다. 너무 빠르면 불필요한 재전송을 하게 되고 너무 길면 문제를 빨리 파악하지 못해서 문제가 생긴 동안 조치를 안하고 있을 수 있음.

재전송을 해야하는데 사고가 날거같으면 선제적 대응이 중요함. 전조증상을 파악해야함. 전조증상 후에 사고가 일어날수도 안일어날수도 있지만 통계적으로 파악해서 그 시점에 재전송을 해줘야하는것임.

## fast retransmit
> duplicate ack를 3번 받으면
ack 안받은 segment를 재전송함. RTT가 길었는데 같은 ack를 3번: 안좋다는 신호임.
> 그러면 타임아웃까지 기다리지 말고 빨리 재전송을 해주자.
타임아웃을 기다리는게 더 안좋을수있다.문제가 생긴 패킷을 빠르게 조치해주기.

예시: RTT느리니까 timeout늘림 -> ack이 같은게 계속옴 -> timeout안지났어도 안기다리고 다시보냄


# TCP Flow Control
> receiver의 buffer만 바라본다.
> buffer에 얼마나있는지 헤더에 receive window 넣어서 보내줌.
> sender가 그것에따라 보내는 양을 조절함.

overflow오면 loss되니까.







# TCP 3-way handshake
> bit 외우기
sender가 synbit 1(ackbit 0)보냄-> receiver가 synbit 1(ackbit 0)보내면서 ackbit 1(synbit 0)보내고 sender가 ackbit 1(synbit 0)보냄
이게 헤더에있음. 이걸 주고받는데 handshake

# TCP Closing (4번)
> bit 외우기
sender: finbit 1, ackbit 0
receiver: finbit 0, ackbit 1, (finbit 받았고 해제준비 한다는뜻.)
sender: 기다림.
receiver: finbit 1, ackbit 0 (해제했다. 이제 receiver는 못보냄.)
sender: finbit 0, ackbit 1 (이러면 receiver가 완전히 끊어짐.)






# Congestion control
flow control, congestion control, duplicate ack 이 뭐가다른건지

다양한 congestion의 원인과 상황. 어렵다.
window size를 적절하게 정해야됨.
node입장에서 selfish함: 네트워크 혼잡도와 상관없이 들어온만큼 보내기 -> 모든 node가 그렇게 하면 네트워크 문제. 그래서 모든 TCP에 이런 정책을 넣으면 어느정도 fair하게 됨 -> 효율적으로 관리됨.
근데 그걸 강제할수있나? TCP를 여러사람이 구현할텐데?







# AIMD
어떻게 해야 망의 입장에서 좋을까? AIMD adaptive increase, multiplicative decrease
잘되면 linear하게 window size를 늘린다.
그러다 문제가 생겼다 -> 순차적으로 줄이는게 아니라 급격하게 줄인다.

단점: 좋을때 너무 천천히 증가시킴. 배수로 증가시켜야 함. 가장 많이 보낼 수 있는 구간인 maximum까지의 도달이 오래걸림. 좋은환경일때 최대로 보낼수있는 곳까지 빠르게 보내자.

# slow start
AIMD의 단점 보완. 한개 보냈다가 2개 4개 8개 이렇게 배수로 보냄.







## Tahoe
threshold는 문제없이 빠르게 잘 보낸 구간(그게 정확히 뭐지?). 히스토리를 보고.

증가시켜도 괜찮은 구간에서 exponential하게(slow start) 하다가 threshold넘으면 linear(AIMD) -> 문제 생기면 처음 값으로 쭉 내려감(AIMD) + threshold를 한 단계 낮춘다.

## Reno
case
Tahoe는 급격하게 떨어지는 기준이 timeout임. 매우 안좋은 환경.
> triple duplicate ack도 안좋긴하지만 전조현상임.
그래서 그걸 기준으로 함.

start point
> 급격히 내려간 다음 시작점을 맨 첫번째 말고 threshold부터 linear로 다시 시작함. -> 회복이 빠름.
> fast recovery.
완전 악조건은 아니니까

## new Reno
duplicate ack났을때 바로 낮출거냐? reno는 문제생길때마다 threshold내려감 -> 환경이 좋아져도 시간걸림.

new reno는 문제가 계속생기면 무시하고 threshold 유지하기.