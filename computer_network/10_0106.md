# Link layer의 서비스
framing, link access
- datagram을 encapsulate -> frame
- MAC 주소로 노드를 인식(하드웨어의 static한 주소)

두 인접노드 간 reliable 전송
- 무선링크 error rate높음. 유선에서는 가끔만 사용됨

flow control
- 두 인접노드 사이 flow control.
- 주변 link들의 간섭으로 error발생가능 -> 기다렸다보낸다던가. CSMA?

error detection/correction
- signal attenuation, noise -> 에러
- receiver가 알아채고 sender에게 재전송요청/frame 버림
- network에서는 빠졌어도(ipv6) 여긴 있음

half-duplex/full-duplex
- 단방향이냐 양방향이냐

# Link Layer는 어디에 있냐?
모든 host마다.
adaptor(NIC network interface card) 또는 chip 속에.
하드웨어,소프트웨어,펌웨어

adaptor가 하는일
- sender: encapsulate datagram -> errorchecking,flowcontrol bit
- receiver: error check,flowcontrol -> extract datagram






# EDC (Error detection and Correction bits)
> 설명

데이터 D는 frame 안에서 EDC와 함께 보내진다.
receiver는 링크를 지나 온 D'와 EDC'을 받는다. 에러체크하고 괜찮으면 추출한다.
EDC가 모든에러를 잡진 못한다.

## Parity checking
single bit parity: 1차원
- d bit라면 d+1 bit가 짝수가 되도록 하는 1 bit 추가.
- 근데 에러가 짝수개 난다면 -> undetected error
- 보통 에러날 때 여러개가 같이남 -> undetected error 확률 50%...

two-dimensional bit parity
- i행과 j열마다 parity값 계산 -> i+j+1개의 parity bit
- 에러한개 -> 어디서 났는지 알고 correction도 가능.
  - sender의 재전송 횟수를 줄여서 좋음. round-trip propagation delay줄임.

## Internet Checksum (Transport Layer에서만)
segment의 byte들을 16 bit int들로 만들어서 다 더함 -> checksum 필드에 넣음 -> receiver가 계산,비교

> 확인필요
- TCP UDP에서는 헤더,바디 다 체크섬함
- IP에서는 헤더만 함(TCP UDP에서 자기꺼다하니까)
- 오버헤드가 적음, 하지만 약함 그래서 link에서는 CRC가 더 많이 쓰임. 왜냐면 transport에서와 달리 link에서는 전용 하드웨어에서 이루어져서 더 복잡한 행동을 할수있기때문.

## CRC (Cyclic redundancy check)
> G랑 R 개념, 계산방법, 결과 판별법 설명하면 됨.
> 흠 아직 정확히 모르겟음

Ethernet, WiFi 등에서 잘 사용되는중.
장점이 머지?무슨문제를해결하지?

D: 데이터의 bit들
G: r+I bit pattern (generator)

r개의 CRC bit R을 선택한다.
- D와 R은 G로 나누어떨어져야 한다.
- receiver는 G를 알아야 한다.

receiver는 G로 D, R을 나눈다(exclusive or)
-> 나누어떨어지지 않으면 에러

r+I 보다 적은 bit의 에러는 알아낼 수 있다.






# Multiple Access protocol
대상에 따른 link의 종류
- point-to-point: 상대편 리시버한테 1:1로 꼭 가야함. Ethernet이나 ppp 프로토콜.
- broadcast: 공유 Ethernet wire나 WiFi. 1:n으로 주변에 뿌려줌.

broadcast에서
- 하나만 보내기 -> no collision 하지만 비효율
- 2개이상 노드에서 동시에 보내기 -> collision(노드가 2개이상 signal을 동시에 받으면), 

최대한 충돌 없게 하기 위해 multiple access protocol.
- node가 channel을 공유하는 방법에 대한 분산된 알고리즘.
- channel 공유에 대한 소통도 그 channel을 씀.

이상적인 프로토콜: channel의 rate가 R bps라면 노드 하나가 전송할때는 R의 rate로, M개의 노드가 전송할 때는 각각 R/M의 rate로 보낼 수 있다. 전송을 관리하는 노드가 있지 않고, clock과 slot이 따로 있지 않고, 단순하다.

# MAC (Media Access Control) 프로토콜 종류
> 중요. 걍 다 외워

1. channel partitioning
- FDMA
- TDMA
- CDMA

2. taking turns
- polling
- token passing

3. random access
- ALOHA, slotted ALOHA
- CSMA, CSMA/CD, CSMA/CA

## Channel Partitioning
- 회선교환처럼 channel을 조각으로 나눠서 노드 독점 배정.
- 충돌 안 생김

FDMA (frequency division multiple access)
- channel의 스펙트럼이 주파수 따라 나뉨
- 사용되지 않고있는 주파수는 idle

TDMA (time division multiple access)
- round에 따라 channel에 대한 접근이 주어짐
- station들은 자신의 round에 고정된 길이(전송시간)의 slot을 얻음
- 사용되지 않은 slot은 idle

CDMA (code division multiple access)
- 3G, 4G(LTE?), 5G... 우리나라에서 상용화를 최초로 함.

## Taking turns
- 노드에게 순서를 정해줌.
- 충돌 안 생김

채널파티셔닝은 부하 적을때 비효율적이고 랜덤액세스는 부하 높을때 충돌많음 -> taking turns

polling
- master 노드가 slave 노드에게 전송하라고 invite
- 단점: polling overhead, latency, single point of failure(master)

tocken passing
- 토큰을 노드마다 돌림 -> 토큰이 나한테 왔을 때 보냄
- 단점: token overhead, latency, single point of failure(master)

## Random Access
> 유무선 여부도

보내는노드 하나밖에없으면 rate 다쓸수있음. 2개이상 동시에보내면 충돌 발생.
-> detect collision
-> recover from collision

- ALOHA (유무선)
- slotted ALOHA (유무선)
- CSMA (유무선), CSMA/CD (유선), CSMA/CA (무선)





# Pure(unslotted) ALOHA
단순하고 동기화가 없다.
보내고싶을때 그냥 보내게한다. -> 이전, 이후 전송된 frame과 충돌 가능

# Slotted ALOHA
보내는 시점을 동기화시켜서 충돌을 줄이자.

가정
- 모든 frame이 같은 사이즈
- 시간을 모두 같은 사이즈의 slot으로 나눔
- 노드는 slot의 시작에만 전송 시작함.
- 노드들은 동기화됨
- 2개 이상의 노드가 slot에서 전송하면 모든 노드는 충돌이라고 생각한다.

작동
- 노드가 새로운 frame을 받음
  -> 충돌이 없으면 다음 slot에 전송한다.
  -> 있으면 매 타임슬롯마다 확률 p로 “다시 보낼지 말지”를 결정한다. 노드 하나가 전송 성공할 때까지.

장점
- 노드 하나가 full rate로 계속 전송할 수있다
- decentralized: 노드가 slot만 싱크하면 됨.

단점
- 충돌있음
- slot 낭비됨(노드들 다같이 기다리면/충돌하면)
- 패킷 다보내기 전에 충돌 감지 가능해도 중단 불가
- clock synchronization: 모든 노드의 시계가 맞아야 함




# CSMA (carrier sense multiple access)
보내기 전에 listen한다.
- channel이 idle이면 전체 frame을 보낸다.
- channel이 바빠 보이면 기다린다.

그럼에도 충돌 발생 가능 (CSMA collision)
- 거리와 전파 지연시간 때문에 체크에 안 걸릴 수 있음 -> 몰랐던 충돌이 발생 가능.

> 차이 숙지

## CSMA/CD (collision detection)
보내고 빨리 collision detection -> 버리고 재전송

키워드: abort, binary exponential backoff

- 유선LAN에서는 쉬움: signal strength 측정, 전송된/받은 signal 비교 쉬움
- 무선LAN에서는 어려움: 받은 signal이 local transmission strength에 묻힘.

Ethernet의 CSMA/CD
1. NIC가 frame만들음
2. NIC가 channel이 idle이라고 sense하면 frame 전송 시작. 아니면 idle해질때까지 기다림
3. NIC가 충돌detection없이 전체frame 보내면 끝, 보내는중에 충돌나면 버리고 jam signal 보냄
4. 버린 후 binary(exponential) backoff에 들어감

- backoff: 기다리기.
- binary backoff: 계속충돌나면 backoff interval을 늘린다 즉 많이기다리게 한다. 많이 기다린다고 무조건 더 좋은 건 아니지만 확률적으로 효율적임.









# MAC주소
- frame을 한 인터페이스에서 다른 물리적으로 연결된 인터페이스로포워딩하기위한.
- 48bit
- 보통 NIC에 새겨져있음
- 예: IA-2F-BB-76-09-AD

LAN의 각 adapter는 고유한 LAN 주소를 가지고있다.(MAC이아니고?)

MAC주소 할당은 IEEE에 의해 관리된다. 생산자가 MAC주소를 산다.

이동가능하다. LAN카드를 어떤 LAN에서 다른 LAN으로 옮길수 있다.
(반면 ip 위계적 주소는 이동아님. 노드가 속한 subnet에 따르기 때문.)

# ARP table
ip 주소를 MAC 주소로 바꾸는 테이블.
LAN의 각 ip 노드(host, router)가 ARP table을 가지고있다.
`<ip주소; MAC주소; TTL>`

- TTL: 보통 20분 (기기가 꺼질수도있고 변할수있으니까)

# ARP (address resolution protocol)

같은 LAN 안에서
1. A가 B한테 datagram보내고싶다. 근데 B의 MAC주소가 A의 ARP table에 없다.
2. A가 B의 ip주소를 포함한 ARP 쿼리 패킷을 broadcast한다.
   - LAN의 모든 노드가 받는다
3. B가 A의 MAC주소로 자기 MAC주소를 보낸다.(unicast)
4. A는 IP-Mac 쌍을 자기 ARP table에 저장한다.
   - soft state: 갱신안된채 TTL 지난 정보(없어진다는겨?)
5. plug-and-play: net관리자랑 상관없이 노드가 알아서 자기 table만들음

다른 LAN으로
1. A에서 R(first hop 라우터) 통해 B에게 datagram 보내고싶다.
   - A는 B,R의 ip주소 알고 R의 MAC주소 안다
2. A는 B한테 보낼 frame에 도착지주소로 R의 MAC주소넣고 R한테보냄
3. R이 받아서
   - datagram지우고 (자기 윗단) ip로보냄
   - ip소스 A,도착지B인 datagram 보냄
4. 도착지로 B의 MAC주소 넣은 frame만들음. datagram은 A가보낸거.