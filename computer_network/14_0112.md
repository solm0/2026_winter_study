# 오디오
오디오는 일정한 rate로 샘플된다~

그래프참조
- quantization error
- quantized value of analog value
- analog signal
- sampling rate(N sample/sec)

# 비디오
CBR (constant bit rate): 비디오인코딩속도 일정
VBR (variable bit rate): spatial/temporal coding changes

- spatial coding: 보라색 N개일때 -> '보라색-N'
- temporal coding: frame i+1 전체 보내지 말고 딱 i과의 차이점만보냄

# 멀티미디어(오디오/비디오) 네트워킹을 하는 경우
- streaming, stored
  - 서버에저장되어있음
  - 전체파일 다운로드 전에 playout 시작 가능
  - 렌더보다 전송이 더 빠름
- conversational (over ip): 지연많이되면안됨
- streaming live






# streaming stored 비디오
challenges
- continuous playout constraint: 클라이언트가 playout시작하면 타이밍을 맞춰야함, 하지만 네트워크지연은 변화무쌍 -> client-side buffer필요
- client interactivity: pause, fast-forward, rewind, jump
- packet loss,retransmit

client-side buffer, playout delay가 네트워크 딜레이를 보상한다.

## client-side buffering, playout
- x(t): variable fill rate
- Q(t): buffer fill level
- r: playout rate
- B: buffer size
- tp: playout 시작 시점

1. tp 전 buffer initial fill함
2. tp에 playout 시작
3. x(t)가 변하니까 Q(t)도 변함. 하지만 r은 일정

x는 평균 fill rate임
- x < r buffer 말라죽음
- x > r buffer 안 마름, initial playout delay가 x(t)의 변동 흡수하기 충분함


## UDP로 멀티미디어 스트리밍
- 서버가 클라이언트한테 알맞은 rate로 전송
  - 대부분: 전송rate = 인코딩rate = 일정함, 하지만 혼잡도에따라다름
- error recovery: application level에서.
- RTP: 멀티미디어 payload 타입
- UDP는 방화벽을 넘지 못할수도있음

## HTTP로 멀티미디어 스트리밍
HTTP GET으로 멀티미디어 파일 받음
TCP에서 최대 rate로 전송

파일 -> TCP send buffer -> INTERNET -> `x(t)` TCP receive buffer -> application playout buffer

TCP congestion control이랑 재전송(in-order) 때문에 fill rate가 변화함
playout delay를 크게 하면 TCP 전달rate가 부드러워짐
HTTP/TCP가 UDP보다 방화벽 잘 통과함







# Voice-over-IP (VoIP)
대화를 유지하기 위한 조건: VoIP end-end-delay requirement
- 지연이 눈에띄고 상호작용 손상시킴. 150ms보다 낮으면 좋고 400ms보다 크면 나쁨
- application level 지연도 있음
  - packetization, playout
- 부가가치 서비스(call fowarding, screening, recording)

# VoIP: 패킷로스,지연에 대해
- network loss: 네트워크 혼잡때문에(라우터buffer overflow) ip datagram 손실
- delay loss: ip datagram이 receiver한테 playout보다 늦게 도착
  - processing,queueing,end-system delays
- loss tolerance: loss 1%에서 10%까지는 참을만함

# RTP (Real-Time Protocol)
RTP는 오디오/비디오데이터 패킷의 구조를 특정함
- payload 타입 인식
- packet sequence numbering
- time stamping

end system에서 실행됨
UDP segment에서 encapsulate됨
호환성: 두개의 VoIP application에서 RTP를 실행하면 같이작동가능

## UDP 위에 RTP
RTP 라이브러리는 UDP를 확장하는 transport layer 인터페이스를 제공한다.
- port number, ip주소
- payload 타입 인식
- packet sequence numbering
- time stamping

## RTP and QoS
- 데이터의 시간에 맞춘 전송이나 다른 QoS 보장하지않음
- end-system에게만 보임. 라우터는 모름
  - 라우터는 best-effort함. 시간맞춰주지않음




## RTCP (Real-Time Control Protocol)
RTP와 결합해 작동함
RTP 세션의 참여자는 모든 다른 참여자들한테 주기적으로 RTCP컨트롤패킷을 전송함
RTCP 패킷은
- sender and/or receiver 리포트
- 리포트 통계는 application에 유용함. (예: 보낸패킷갯수,손실패킷갯수,jitter)
피드백은 performance를 컨트롤하는데 쓰임. sender가 전송을 조절할수있음


## RTCP multiple multicast senders
multicast와 broadcast는 다른건가
- 각 RTP 세션은 보통 하나의 multicast 주소임. 세션에 속한 모든 RTP/RTCP 패킷은 multicast 주소를 사용함.
- RTP,RTCP 패킷은 서로에게 서로다른 port number 기준으로 식별됨
- 각 참여자는 회의참여자가 늘어날수록 RTCP트래픽을 줄임. 트래픽을 제한하기 위해서

## SIP (Session Initiation Protocol)
- 전화,회의 모두 인터넷에서일어남
- 사람은 이름이나 이메일주소로 식별됨(폰번호말고)
- 통화대상자가 어디가든, 어떤ip가진장비를 사용하고있든 전화걸수있음

### SIP이 하는것
통화셋업
- 수신자한테 발신자가 통화하고싶음을 알림
- 발신자/수신자가 media타입과 인코딩에 동의
- 통화 끝내기

수신자의 현재 ip주소알아내기
- identifier를 현재 ip주소에 맵함

통화관리
- 통화중에 새로운 media streaming추가
- 통화중에 인코딩을 바꿈
- 다른사람 초대
- transfer, hold






# best effort network의 크기를 정하기?
접근법: 넉넉한 link capacity를 배포 -> 혼잡생기지않고 멀티미디어트래픽 지연/손실안생기게
- 복잡성낮은 네트워크
- 대역폭 cost 큼

challenges
- network dimensioning: 충분한 대역폭이 얼마인가?
- 트래픽 측정 수요: 충분한 대역폭이 어느정도인지 알아야

# 서비스의 여러가지 class를 전달하기??
지금까지: best effort service를 만들기, 하나의 사이즈가모든서비스모델에 맞게
대안: 서비스의 multiple class
- 트래픽을 classes로 구분하기
- 서로다른 class의 트래픽을 다르게 취급하기

개인이 아니라 class에 따라서 다르게 서비스하기





# 시나리오: HTTP와 VoIP섞기
> 규칙 1: 라우터가 class를 구분할수있게 패킷에 표시해야하고. 새 라우터 정책이 이를 따라야함
예를들어
1 Mbps VoIP와 HTTP가
1.5 Mbps link를 공유한다고 치자

HTTP가 커지면 라우터에서 오디오 손실시킬수있음 -> 오디오에게 우선권을



## QOS 보장을 위한 규칙들
> 규칙 2: class를 나머지에게서 보호/독립시켜야

만약 application이 잘못행동하면? 예를들어 VoIP가 정해진 rate보다 많이전송하면?
- policing: 소스가 대역폭 배정을 지키게 강제하기

marking, policing을 네트워크 말단에서 해야 함.

> 규칙 3: 독립시킬때 자원을 효율적으로 쓰기

고정된,혼자만의 대역폭을 할당할때 그거 다 안쓰면 비효율적임.




packet scheduling: queue중에 다음으로 전송할 패킷 정하기
  - FCFS (first come first served)
  - multi-class priority
  - round robin
  - WFQ (weighted fair queueing)

> 규칙 4: call admission - flow는 자기가 필요한거 선언하지만 안되면 네트워크가 차단할수도있음.

basic fact of life: link capacity보다 큰 트래픽수요 지원불가.

## QOS 보장 시나리오
- 리소스 reservation: 통화 셋업, signalling(RSVP), 트래픽, QOS선언, 요소별 admission control