# P2P 구조
항상 돌아가는 서버가 없고, 유저의 end system들이 peer로서 직접 소통한다.
peer는 클라이언트인 동시에 서버다. 간헐적으로 연결되고 ip주소가 바뀐다.

cs구조에서는 서버가 할일이 많고 대역폭이 많이 필요할 것이다. 하지만 P2P구조는 peer를 참여시켜서 분산시킨다.

## 시뮬레이션해보자.
- Us: 서버(업로드하는 peer)의 access link의 upload rate
- Ui: i번째 peer의 access link의 upload rate
- Di: i번째 peer의 access link의 download rate
- F: 파일크기 bit
- N: 파일 받고싶어하는 peer의 수

distribution time = N명 모두에게 파일을 주는 시간.

### CS구조
- 서버 하나가 N명에게 F bit의 파일을 전송해줘야 한다 -> Distribution time = NF/Us
- Dmin = min{D1, D2, ... DN} 이라 하면 최소 distribution time은 최소 F/Dmin이다.

-> `D = max{NF/Us, F/Dmin}`

NF/Us는 서버 병목에서나온 서버입장 최소시간.(서버는 대역폭을 나눠쓸테니까 NF임)
F/Dmin는 클라이언트 병목에서 나온 클라이언트입장 최소시간.

서버 ↔ 공통구간 ↔ 개별링크(i) ↔ 클라 i
      (Us)      (Di)

Us와 Di는 따로 계산되고 그중 최대의 병목이 전체의 병목이 되고
클라이언트 숫자 N이 많아질수록 소요시간이 많아진다.

### P2P구조
- 처음에 파일을 가진 서버는 한번 access link에 올려야 한다. -> F/Us
- 가장느린클라이언트 F/Dmin
- 업로드capacity는 서버+참여peer의 upload rate의 합이다. -> Utotal = Us + U1 + ... + UN -> 시간은 NF/Utotal

`D = max{F/Us, F/Dmin, NF/(Utotal)}`?

cs구조는 직렬이고 p2p는 병렬이군

## BitTorrent
> titfor tat evaluation주기chunk같은키워드 가지고 설명하기.
유명한 P2P 파일 분배 프로토콜.
특정한 파일의 분배에 참여하는 peer들의 모음을 torrent라고 한다.
torrent의 peer들은 서로에게서 파일을 256kb의 청크 단위로 쪼갠 것을 받는다.

1. peer가 처음 torrent에 들어오면 chunk가 없다.
2. 시간이 지나면서 chunk가 누적된다. 다른사람거 다운로드하면 그 chunk를 다른 peer에게 업로드하게된다.
3. peer가 파일 전체를 얻었을 때 먹튀할수도 있고, torrent에 남아서 다른 peer에게 업로드해줄수도 있다.(churn)

각각의 torrent에는 tracker라는 노드가 있다.
peer가 torrent에 들어올 때, tracker에 자신을 등록하고
주기적으로 자신이 torrent에 계속 있음을 tracker에게 알린다.

상황
- 앨리스가 토렌트에 들어왔다.
- 트래커가 peer의 subset을 랜덤하게 선택해서 ip주소를 앨리스한테 보냈다. 
- 앨리스는 모두에게 TCP connection을 시도한다.
- connection에 성공한 peer들을 이웃이라고 부르자. 이웃은 계속 바뀔 것이다.

- 각 peer는 파일의 서로 다른 chunk의 subset을 갖고있다.
- 앨리스는 주기적으로 이웃에게 자신이 가진 chunk의 list를 요구한다.
- 앨리스는 자신에게 없는 chunk를 요청할 것이다.
  - 어떤 chunk를 요청? 이웃들사이 희귀한 것부터 -> chunk의 복사본 갯수를 고르게함
  - 누구에게 chunk를 전송? 가장 높은 rate로 주고있는 이웃에게.
    - 앨리스에게 bit을 주는 이웃의 rate를 측정해서 가장 빠른 4명을 정한다. 그들에게 chunk를 준다.
    - 10초에 한 번씩 rate를 재계산하고 4명을 수정한다. unchoked
    - 30초에 한 번씩 새로운 이웃을 선택해서 chunk를 보낸다. optimistically unchoked. 둘이 만족하면 서로의 4명에 들수도.
    - 그렇게해서 최적의파트너를 찾고, 새로운peer를 참여시킨다








# Video
비디오는 일정한 시간마다 보여지는 이미지(24-30/s)의 연속이다.
이미지는 픽셀의 배열이다. 픽셀은 bit의 배열이다.

높은 bit rate 100kbps-4mbps를 요구. 평균 end-to-end 대역폭이 압축된 비디오의 bit rate만큼 커야 한다. 압축 정도를 선택하게 할 수도 있다.

## buffer

인터랙션이 너무 자유롭지만 playout이 지속적이어야 한다.
playout은 도착한 패킷을 언제 재생할지 결정하는 것, 지연(jitter)를 고려해 버퍼에서 꺼내는 시점을 조절하는 것, 원래 영상이 가진 시간에 맞춰 출력하는 것이다.

클라이언트에게 byte들이 오면 클라이언트application buffer에 저장된다. byte가 미리정해진 threshold를 넘으면 application은 플레이백을 시작한다. 플레이백: 주기적으로 buffer로부터 프레임을 가져와서 압축을 풀고 스크린에 보여준다.

HTTP 스트리밍할때 문제점: 유저/시간에 따라 서로 다른 환경.

## DASH(Dynamic Adaptive Streaming over HTTP)
> dash가왜쓰이는지 manifest파일쓴다 정도
![](./assets/playout-buffering.png)

비디오가 bit rate에 따라 몇개의 다른 버전으로 encode됨 -> 클라이언트가 주기적으로 대역폭 측정 -> chunk들을 request함. 
- encoding rate: 현재 대역폭에서 최대한의 rate를 선택함.
- 언제 chunk를 요청할지: buffer가 마르거나 너무 많지 않게
- 어느 서버에 chunk를 요청할지: 가깝거나 대역폭 높은 url 서버에서 요청

서버에 서로 다른 버전이 서로 다른 url로 저장되어 있다.
- manifest file: bitrate마다 버전의 url을 담고있음. 클라이언트가 찾을수있게.

## CDN

하나의 큰 서버로 안되는 이유
- 전세계에 사용자가 너무 많고 큰 대역폭 요구한다.
- 유명한 비디오가 불필요하게 중복되어 보내진다.
- single point of failure

그래서 CDN(Content Distribution Network)를 이용한다.
- 분산된 지역 -> 최적의 서버에서 제공
- 비디오의 사본 저장

CDN은 content provider의 개인cdn일수도(Google), third-party cdn일수도(Akamai). 서버배치 철학
- Enter Deep: access ISP들에 둔다.
- Bring Home: IXP에 둔다.

많이 시청된 비디오만 캐시함.

중복을 이용한다
- 이미지 내에서 spatial coding: 같은 색이 N개 있으면 색의 값과 N을 보냄.
- 이미지 사이 temporal coding: 아예 새로운 프레임을 보내는 것이 아닌 전 프레임과의 difference만 보냄.

`TBD` CDN, 아마존 예시







# Socket Programming
> udp tcp구현레벨말고 차이확실히알아두기.
application은 앱 개발자가 제어, transport이하 부분은 os가 제어
transport는 process를 process에 연결하는 역할이다.

socket은 application process와 end-end-transport protocol 사이의 문이다.



- TCP, UDP 클라이언트코드,서버코드(상호작용),헤더에 있어야하는 정보 비교

# socket with UDP
- sender는 각 패킷에 도착 ip주소와 포트넘버를 붙인다.
- receiver는 받은 패킷에서 sender ip주소와 포트넘버를 추출한다.?

## 클라이언트/서버 상호작용
- 클라이언트가 socket 만들음 `clientSocket = socket(AF_INET, SOCK_DGRAM)`
- 서버가 socket 만들음 `serverSocket = socket(AF_INET, SOCK_DGRAM)`
- 클라이언트가 서버의 ip와 포트넘버와 함께 datagram을 만들어 `clientSocket`을 통해 전송
- 서버가 `serverSocket`에서 datagram을 받음
- 서버가 `serverSocket`에 클라이언트 ip주소와 포트넘버와 함께 응답을 작성
- 클라이언트가 `clientSocket`에서 datagram 읽음
- 클라이언트가 `clientSocket` 닫음.

### UDP 클라이언트 예시
```py
from socket import *
serverName = 'hostname'
serverPort = 12000

clientSocket = socket(AF_INET, SOCK_DGRAM)
message = raw_input('Input lowercase sentence:')
clientSocket.sendto(message.encode(), (serverName, serverPort))

modifiedMessage, serverAddress = clientSocket.recvfrom(2048)
print modifiedMesssage.decode()
clientSocket.close()
```

### UDP 서버 예시
```py
from socket import *
serverPort = 12000

serverSocket = socket(AF_INET, SOCK_DGRAM)
serverSocket.bind(('', serverPort)) # 로컬포트넘버 12000에 socket을 bind한다
print("The server is ready to receive")

while True:
  message, clientAddress = serverSocket.recvfrom(2048)
  modifiedMessage = message.decode().upper()
  serverSocket.sendto(modifiedMessage.encode(), clientAddress)
```

- 왜 서버소켓을 안닫지? -> 서버는 항상 열려있어야 함, 프로세스 종료하면 os가 자동으로 소켓 회수해서 close 안필요함.
- 왜 bind에 ''라고 돼있지? -> '' = 0.0.0.0
  - 0.0.0.0는 모든 인터페이스를 뜻함. 로컬이나 특정 NIC에서만 받는게 아니라.




# socket with TCP

## 클라이언트/서버 상호작용
- 서버가 request를 받기위한 socket을 만든다 `serverSocket = socket()`
- 서버가 request를 기다린다 `connectionSocket = serverSocket.accept()`
- 클라이언트가 socket을 만든다 `clientSocket = socket()`
- 클라이언트가 `clientSocket`으로 request를 한다
- 서버가 `connectionSocket`으로 request를 받아서 읽는다
- 서버가 `connectionSocket`에 응답을 작성한다
- 클라이언트가 `clientSocket`에서 응답을 읽는다
- 서버가 `connectionSocket`을, 클라이언트가 `clientSocket`을 닫는다

### TCP 클라이언트 예시
```py
from socket import *
serverName = 'servername'
serverPort = 12000

clientSocket = socket(AF_INET, SOCK_STREAM)
clientSocket.connect((serverName, serverPort))
sentence = raw_input('Input lowercase sentence:')
clientSocket.send(sentence.encode())

modifiedSentence = clientSocket.recv(1024) # 서버이름과 포트넘버가 필요없음.
print('From Server:', modifiedSentence.decode())
clientSocket.close()
```

### TCP 서버 예시
```py
from socket import *
serverPort = 12000

serverSocket = socket(AF_INET, SOCK_STREAM)
serverSocket.bind('', serverPort)
serverSocket.listen(1)
print('The server is ready to receive')

while True:
  connectionSocket, addr = serverSocket.accept() # accept()로 기다리다가 request 오면 새로운 socket 만들어짐.

  sentence = connectionSocket.recv(1024).decode() # UDP와 달리 서버이름과 포트넘버 필요없음.
  capitalizedSentence = sentence.upper()
  connectionSocket.send(capitalizedSentence.encode())
  connectionSocket.close()
```


# Multiplexing & Demultiplexing
> 어디에서일어나고 어떤의미인지.
서버 transport에서 일어나는 일. application으로부터 socket을 통해 데이터를 받는다.

- sender - multiplexing: 여러 socket에서 온 데이터를 받아서 transport 헤더를 붙인다
- receiver - demultiplexing: 데이터(datagram, segment)에 있는 header(도착지/출발지 ip주소와 포트넘버 갖고있음)를 사용해서 segment들을 알맞은 socket으로 보낸다

TCP와 UDP의 헤더는 확연히 다름. UDP가 더 단순함.
TCP는 4tuple중에 하나라도 다르면 다시연결을만들음.

> 소켓생성할떄 tcp와 udp의 차이.
> udp는 소켓하나만, tcp는 4가지조합중 하나만다르면 새로생성하낟.
## Connectionless Demultiplexing
만들어진 서버의 socket은 포트넘버를 가지고있겠지
UDP socket으로 데이터를 보낼때는 도착지의 ip주소와 포트넘버만 명시.
데이터를 받을 때도 segment에 있는 도착지 포트를 확인해서 그 포트넘버를 가진 socket으로 보내야 하고.

![](./assets/connectionless-demul.png)
? 그림이상함?

서버가 열린 socket한개로 여러 클라이언트 socket에서 받아서 서버의 출발포트를 명시안해도 됨? 그게아닌거같은데.

## Connection-oriented Demultiplexing
TCP소켓은 4-tuple 필요. 출발지/도착지의 ip주소와 포트넘버.
데이터 받을때 4-tuple이용해 알맞은 socket으로 보내준다.

![](./assets/connection-demul.png)








## UDP Segment Header
> 키워드들. nofrill barebons best effort...
- length: segment의 bytes(헤더포함)
- checksum: 에러난거는 반영하면 안되니까

## UDP Checksum
> udp segment, checksum. 방식설명필요없음.
에러 체크함
- sender: segment를 16bit integer로 취급, segment content의 addition을 체크섬이라고 함. sender가 체크섬 값을 넣음
- receiver가 받은 segment의 체크섬을 계산함, 체크섬 필드와 같으면 에러없음
 
근데 체크섬값이랑 실제비트랑 뭐가다른건지? UDP에서는 헤더도 깨질수있느거아닝야? 헤더는 안깨지는거라면 헤더에다 값을넣으면안돼?