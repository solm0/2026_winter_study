# NAT (network address translation)
> NAT가 왜생겻고 어떤역할

외부 라우터의 관점에서 로컬 네트워크(안쪽)는 ip 주소 하나만 사용하는 것처럼 보인다.
NAT는 (동적이든 정적이든) 할당된 ip를 다른 ip로 변환해서 쓰는 방법임. 그렇게 해서 공인 ip의 부족을 보완할 수 있다.

하나의 NAT ip 주소, 서로 다른 포트넘버를 가진다.

1. host 10.0.0.0이 128.0.0.0, 80으로 보냄 
2. NAT 라우터가 소스주소를 138.0.0.0, 5001로 바꿔치기함
3. 128.0.0.0에서 138.0.0.0, 5001로 옴
4. NAT 라우터가 목적주소를 10.0.0.0으로 바꿔치기함.

단점
- 라우터는 ip만 보고 넘기는게 좋은데 포트까지 보니까 복잡함
- ipv6가 주소부족 해결가능
- p2p때 방화벽때문에 불편





# ipv6
> ipv4와의 차이, 헤더 변화

+ address 숫자가 적으니까 늘림. 32(4byte) x 4 = 128(16byte)
- 대신 헤더에서 불필요한 필드 없앰 -> processing 단순

- 헤더 40B 고정(ipv4는 20-60B)
- checksum 없어짐
  - ip의 checksum은 라우터에서 하니까 tcp보다 빈번
  - 광케이블로 바뀌고 라우터 좋아져서 bit error 잘 안남
- fragmentation 안함
  - 장비표준화되면서 frag해야하는환경이별로없어짐.

Qos: Quality of Service. 트래픽마다 서로 다른 품질 보장(우선순위, 지연 보장, 손실최소화)

- priority: 혼잡 시 어떤 패킷을 먼저 처리할지 결정
- flow label: 같은 flow에 속하는 패킷 인식(한 화상통화 세션)
- next header: 상위레이어 protocol을 나타냄
- hop limit: 몇 hop까지가능한지

ver pri flowlabel             -> 4byte  = 32bit
payloadlen nexthdr hoplimit  -> 4byte  = 32bit
srcadd                       -> 16byte = 128bit
destadd                      -> 16byte = 128bit
                                40byte = 320bit

# Tunneling
> 어떤헤더를 붙엿다 데는지

ipv6 datagram을 ipv4 datagram의 payload로 넣음.

a,b,e,f가 ipv6고 c,d가 ipv4면
ipv6 헤더의 src는 a, dest는 f
ipv4 헤더의 src는 b, dest는 e







# 라우팅 프로토콜
> 중요. LS,DV의 특징.

라우팅알고리즘을 구현한 규약
보내는 host에게서 받는 host까지 최적의 path(최단경로)를 결정하는.
path: 패킷이 거쳐갈 라우터의 sequence

## 네트워크(라우터-링크)를 그래프로 추상화
G = (N, E)
N = {...}
E = {(,),(,),(,)}

c(x,x') = 링크 (x,x')의 비용.
링크의 cost는 대역폭에 반비례하거나 혼잡도에 반비례한다.
path의 cost는 거치는 모든 링크의 cost의 합이다.

라우팅 알고리즘의 목적은 least cost path이다.

## 라우팅 알고리즘의 분류
> 계산 문제는 안 나옴, 설명할 수 있어야 함.

centralized, global (link state LS)
- 모든 라우터가 토폴로지(노드식별자,어떤노드어떤노드연결됐는지)와 link cost 정보를 가진다
- link state algorithm

decentralized (distance vector DV)
- 라우터는 물리적으로 연결된 이웃만 알고, 그에 연결되는 link의 cost만 안다.
- 반복적으로 계산, 이웃과 정보 교환

- static: 관리자가 수동으로 가끔 바꿈.
- dynamic: 동적. 주기적. 라우트가 link cost 변화에 따라 업데이트







# Dijkstra's
> oscillaton

- LS
  - 모든 노드들이 토폴로지와 link cost 알고 있음(link state broadcast에 의해)
  - 한 노드에서 모든 다른 노드로의 least cost path 계산 -> 그 노드의 forwarding table 만들어짐.(itration 횟수는 dest.노드 갯수와 같음)
- Dynamic

c(x,y): 인접이웃 아니면 일단 무한대
D(v): 도착노드 v까지의 현재 cost
p(v): 도착노드 v까지의 path에서 v 이전의 노드
N': least cost path가 알려진 노드들(방문한 노드들)

## Initialization
1. u에서 v가는 cost 저장

```py
N' = {u}
for all nodes v
  if v adjacent to u
    then D(v) = c(u,v)
  else D(v) = ∞
```

## Loop
2. 방문하지 않은 노드 중 가장 비용이 적은 노드 w 선택
3. 그냥 v가는 cost, w 거쳐서 v가는 cost 중 최솟값 선택

```py
find w not in N' which D(w) is a minimum
  add w to N'
  update D(v) for all v adjacent to w and not in N'
    # D(v) = min(D(v), D(w) + c(w,v))
  until all nodes in N'
```

4. 2,3번 반복



## 단점
- algorithm complexity: 모든 노드 확인해야함
- oscillations: link cost가 트래픽에 따라 바뀌면 두 경로 사이 왔다갔다할수있음.








# Bellman-Ford
> 바로 다음node까지만ㅇ ㅏㄹ고있다 등이론적ㅇ니 거 이ㅏㄹ고있기
- DV
- Dynamic

let
  dx(y) = x에서 y로가는 least cost path의 cost
then
  dx(y) = min{c(x,v) + dv(y)}

x의 모든 이웃 v에 대해
x에서 v가는 cost와 v에서 y가는 least-cost의 합
들의 최솟값이
x에서 y가는 least-cost이다.

노드 x는 이웃 v의 목적지 y로 가는 distance vector(least cost, next hop)를 저장한다.

DV는 자신의 distance vector를 계속 이웃에게 보낸다.
x가 새로운 dv를 이웃에게서 받으면 자신의 dv를 B-F equation 써서 고친다.

iterative, asynchronous.
link cost나 이웃의 dv가 바뀌면 iteration이 시작됨.
자신의 dv가 바뀔 때만 이웃에게 알린다.


1. 모든 edge 하나씩 확인
2. 각 edge 거쳐 다른 노드로 가는 비용 계산해 최단 거리 테이블 갱신
3. 3,4번 반복

- x에서 y까지 가는 path 중 다음 노드 v까지 가는 최솟값
- v 이후는 모름. 다음노드는 v한테서 받아야 됨.



서로서로 알고있는 cost를 공유하면서 라우트를 실시간으로 바꿈.




# 비교
> LS

노드 X가 가진 전체 토폴로지 그래프
노드: {A, B, C, D, X}
링크: 
X - A (cost 2)
X - B (cost 5)
B - D (cost 3)
C - D (cost 4)
...

- 전체 토폴로지 정보 -> 바로 최단경로 계산
- X는 모든 노드와 링크 상태, 비용 정보를 알고 있음
- Dijkstra 알고리즘으로 최단 경로 계산

> DV

노드 X 테이블 예시
+-------------+------+----------+
| Destination | Cost | Next Hop |
+-------------+------+----------+
| A           | 2    | A        |
| B           | 5    | C        |
| C           | 1    | C        |
| D           | 7    | B        |
+-------------+------+----------+

- DV는 처음엔 제한된 정보 -> 점진적 학습
- X는 목적지별 최소 비용과 next hop만 저장
- X가 직접 연결된 링크 정보만 알고 있음
- X는 이웃 Y,Z의 DV를 받아 테이블 업데이트