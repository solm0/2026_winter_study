# packet delay

d nodal = d proc + d queue + d trans + d prop

패킷이 노드에 들어옴

-> d proc: nodal processing
- check bit errors: 에러 있는지 확인
- 라우터가 전체를 보고 다음노드가 뭔지 알려줌: determine output link
- (pingpong: 계속 돌음)서비스에 따라 돌아가도 되는지 바로 가야하는지 다름. 메일은 타임에 민감하지 않음. 실시간이 중요한 데이터도 있음. 이런건 타임 조정이 필요함. ttl 오버했는지 어디에 몇번이나 갔는지 보고 버림.

-> d queue: queueing delay
- 큐는 그 당시 얼마나 쓰고있냐에 따라 drop이 생길 수 있다.

-> d trans: transmission delay
- l(packet length bits) / r(link transmission rate bps)

-> d prop: propagation delay
- d(length of physical link) / s(propagation speed)

# throughput
bit이 받을사람한테 갈 때의 rate(bits/time unit), 어느 길로 가는지, 장비의 상황, 받는 서버 상태 등에 따라 다름.
어느 한 시점만 봐서는 end-to-end throughput을 알 수 없다.
bottleneck link: throughput을 저해하는 요소

# network security
보안이 강하면 불편함
virus는 실행하면 작동, worm은 스스로 실행함. 둘 다 자기복제

- dos: denial of service. 좀비 pc가 tcp의 동기화 시스템 three hand shaking을 이용해 서버에 계속 보냄
ddos: distribute of dos. 수백개가 하나의 서버에 많은 메세지를 보냄 -> 서버가 메세지 처리하는라 원래 해야 하는 일을 못함.

- sniffing
지나가는 패킷을 읽고 저장함

- ip spoofing
가짜 address가 담긴 packet을 보냄

# protocol layers and reference models
각각의 레이어가 계층화되어있고 같은 계층은 작동이 유사하다.
- application(IMAP메일서버,SMTP메일서버,HTTP)
- transport(TCP,UDP)
  - tcp: 신뢰성 있는 통신.
  - udp: 빨리 간단히
- network(IP, routing protocols) IP 주소기반으로 라우팅. 멀티
- link(Ethernet, 802.11WIFI, PPP) 원. 다음번 노드에만 관심있음. 포워딩.
- physical

한 개의 계층을 내려갈 떄마다 header를 붙여줘야 함. 예를 들어 application에서 transport로 갈때 tcp header를 붙여줘야됨.

switch는 forwarding하는 link까지부터 있음. 한개만
router는 routing하니까 network부터 있음. 멀티

destination에서는 link에서 받아서 거꾸로 헤더를 떼면서 위로 올려줌

# application layer
- cs(client-server)구조: 중앙에 서버 하나. 해당 서버가 망하면 다 망함. -> 분산 중요
- peer-to-peer 구조: 분산. 서버가 없음. 참여하는 개개인이 서버가 됨. -> 효율적일 수 있음. 토렌트, 비트코인.

socket: application과 transport의 중간에 있음

# CS paradigm
서버
- 항상 있어야
- IP있어야

# peer-peer architechure
- 서버 항상 필요 x

# process
host에 의해 실행되는 program
- messages: 서로 다른 host 사이 소통
- inter-process communication: 한 host에서 두 process가 소통

원래 밖으로 나갈려면 랜선을 꽂아야 함. 하지만 노트북 하나에서 외부로 나가는 소켓을 쓰지만 api만 룩백 쓰면 하나의 노트북에 서버와 클라이언트를 띄울 수 있음.

socket을 파이썬으로 만들어
채팅프로그램 만들기
http올려 와이어샤크로 확인
case 하나하나 동작하게(get하면 파일을 주게, 유저관리, db구축 등등, get할때 조건 붙이기,...)

이거 내 게임만들때 쓸수있겠는데?

# addressing processes
- 메세지를 받으려면 Processsms identifier를 가져야 함. host device는 32-bit IP주소를 가지고 있음.
- 포트넘버: process를 구분함. 한 host에서 여러개의 processr가 실행되고 있어서 구분해야됨.
  - HTTP는 80, mail server는 25
  - 자주 사용되는 포트 well known port

# application layer protocol
- request와 response가 있음
- RFC에 표준이 정의되어 있음.

app에 따라 어떤 transport service가 필요한지는 다르다.
- 데이터 신뢰성
- 시간
- throughput 효율
- 보안

# tcp
- reliable. 데이터 유실이 있으면 안됨.
- flow control: 받는쪽에서 다 차면 그만보내야됨. timeout
- congestion control: 리시버뿐 아니라 네트워크 환경 전체 보고 복잡도가 올라가면 기다리기. 복잡도가 높음을 암시하는 신호들(응답 timeout)을 봐서 유추
- 타이밍, throughput, 보안은 tcp 단에서는 보장해주지 않음. app에서 해야
  
# udp
- 계속 보내기만함.빠르기만하면 됨.
- reliability, flow control, congestion control 없음.

TLS: transport layer security